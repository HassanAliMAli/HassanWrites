import { jsonResponse, errorResponse } from '../utils';

export const onRequestPost = async ({ request, env }) => {
    try {
        const { slotId, signature, timestamp } = await request.json();

        // 1. Verify Signature (HMAC-SHA256)
        // In a real implementation, we would verify the signature generated by the client
        // using a shared secret or public key.
        // For Phase 3, we'll simulate this check.

        // const isValid = verifySignature(signature, slotId, timestamp, env.AD_SECRET);
        // if (!isValid) return errorResponse('Invalid signature', 403);

        if (!slotId || !signature) {
            return errorResponse('Missing slotId or signature', 400);
        }

        // 2. Store Impression in D1
        const id = crypto.randomUUID();
        await env.DB.prepare(
            'INSERT INTO impressions (id, slot_id, signature, timestamp) VALUES (?, ?, ?, ?)'
        ).bind(id, slotId, signature, timestamp || Date.now()).run();

        // 3. Update Aggregated Stats (Async via DO)
        // Fire and forget
        const idObj = env.DASHBOARD_DO.idFromName('global');
        const stub = env.DASHBOARD_DO.get(idObj);
        stub.fetch('http://do/record', {
            method: 'POST',
            body: JSON.stringify({ type: 'impressions', value: 1 })
        });

        return jsonResponse({ success: true, id });

    } catch (err) {
        return errorResponse(err.message, 500);
    }
};
